---
description: Complex project management - Multi-file, architectural planning and large-scale coordination
globs:
  - "**/*.js"
  - "**/*.jsx"
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.vue"
  - "**/*.py"
alwaysApply: false
priority: 3
triggers: ['multi_file_project', 'architecture_change', 'large_feature_implementation', 'system_refactoring']
conditions: ['file_count > 5', 'complexity = complex', 'architectural_impact = high']
planning_required: true
mcp_tools: ['sequential-thinking', 'context7']
depends_on: ['codebase-analysis.mdc', 'file-size-enforcement.mdc', 'quality-gates.mdc']
---

# COMPLEX PROJECT MANAGEMENT - SYSTEMATIC APPROACH

## DEFINITION AND SCOPE - COMPLEX PROJECT CRITERIA

Complex project definition is determined by objective criteria and requires different management strategies.

### COMPLEX PROJECT CRITERIA
**Technical complexity indicators:**
- 5+ file modifications or creations
- Multiple component interaction
- Architecture pattern changes
- Cross-module dependencies
- Performance impact considerations
- Database schema changes

**Business complexity indicators:**
- Multiple user workflows affected
- Backward compatibility requirements
- Integration requirements (3rd party APIs)
- Security implications
- Scalability concerns

### PROJECT TYPE DETECTION SYSTEM

```javascript
function assessProjectComplexity(requirements) {
    const complexityFactors = {
        fileCount: countAffectedFiles(requirements),
        dependencyDepth: analyzeDependencyChain(requirements),
        architecturalImpact: assessArchitecturalChanges(requirements),
        integrationNeeds: identifyIntegrationRequirements(requirements),
        performanceImplications: evaluatePerformanceImpact(requirements)
    };
    
    const complexityScore = calculateComplexityScore(complexityFactors);
    
    if (complexityScore > 0.7) return 'HIGHLY_COMPLEX';
    if (complexityScore > 0.4) return 'MODERATELY_COMPLEX';
    return 'SIMPLE'; // In this case simple-task-handling.mdc activates
}
```

## MULTI-PHASE PLANNING - PHASED PLANNING

### PHASE 1: COMPREHENSIVE ANALYSIS
Detailed analysis and planning phase:

```javascript
function comprehensiveProjectAnalysis(projectScope) {
    return {
        codebaseMapping: analyzeCurrentCodebase(),
        impactAssessment: calculateChangeImpact(projectScope),
        riskAnalysis: identifyRisksAndMitigation(),
        resourcePlanning: estimateTimeAndComplexity(),
        dependencyPlanning: mapDependencyChanges(),
        testingStrategy: planTestingApproach()
    };
}
```

**Analysis deliverables:**
- Current architecture documentation
- Change impact matrix
- Risk register with mitigations
- Implementation timeline
- Dependency update plan
- Testing and validation strategy

### PHASE 2: ARCHITECTURE DESIGN
Architectural design and pattern determination:

**Design principles for complex projects:**
- Single Responsibility Principle (each file single task)
- Dependency Inversion (loose coupling)
- Interface Segregation (minimal interfaces)
- Open/Closed Principle (extension friendly)
- File Size Compliance (file size limits)

**Architecture documentation:**
```javascript
const architectureDoc = {
    componentHierarchy: defineComponentStructure(),
    dataFlow: mapDataFlowPatterns(),
    apiDesign: designInternalAPIs(),
    errorHandling: planErrorHandlingStrategy(),
    stateManagement: designStateArchitecture(),
    fileSizeCompliance: ensureFileSizeManagement()
};
```

### PHASE 3: IMPLEMENTATION ORCHESTRATION
Coordinated implementation process:

**Implementation sequence planning:**
1. **Foundation components** (core utilities, types)
2. **Service layer** (API calls, business logic)
3. **UI components** (presentational components)
4. **Integration layer** (component connections)
5. **Testing and validation** (comprehensive testing)

## DEPENDENCY ORCHESTRATION - DEPENDENCY MANAGEMENT

### DEPENDENCY MAPPING
Dependency management is critical in complex projects:

```javascript
function createDependencyMap(projectScope) {
    const dependencyGraph = {
        internalDependencies: mapInternalComponentDeps(),
        externalDependencies: listExternalLibraryDeps(),
        circularDependencies: detectPotentialCircularDeps(),
        unusedDependencies: identifyUnusedDeps(),
        conflictingDependencies: findVersionConflicts()
    };
    
    return optimizeDependencyStructure(dependencyGraph);
}
```

### IMPORT STRATEGY PLANNING
Import structure planning in large projects:

**Import organization patterns:**
- **Barrel exports**: Related components grouped
- **Lazy loading**: Performance optimization
- **Dynamic imports**: Code splitting support
- **Type-only imports**: TypeScript optimization

```javascript
// Example optimal import structure
// utils/index.js - Barrel export
export { formatDate } from './dateUtils';
export { validateEmail } from './validationUtils';
export { debounce } from './performanceUtils';

// components/index.js - Selective exports
export { Button } from './Button/Button';
export { Modal } from './Modal/Modal';
// Lazy load large components
export const Dashboard = lazy(() => import('./Dashboard/Dashboard'));
```

## RISK MANAGEMENT - RISK MANAGEMENT

### RISK IDENTIFICATION MATRIX
Risk categories for complex projects:

**Technical risks:**
- File size violations during development
- Performance degradation
- Architecture complexity growth
- Integration failures
- Backward compatibility breaks

**Project risks:**
- Scope creep (scope expansion)
- Timeline extensions
- Resource availability
- Quality compromise pressures

### RISK MITIGATION STRATEGIES

```javascript
function implementRiskMitigation(identifiedRisks) {
    const mitigationPlan = identifiedRisks.map(risk => ({
        risk: risk.description,
        likelihood: risk.probability,
        impact: risk.severity,
        mitigation: generateMitigationStrategy(risk),
        contingency: planContingencyAction(risk)
    }));
    
    return prioritizeRiskActions(mitigationPlan);
}
```

**File size risk mitigation example:**
```
ğŸ¯ Risk: File size limit violations
ğŸ“Š Likelihood: High (complex projects)
ğŸ’¥ Impact: Critical (implementation blocker)
ğŸ›¡ï¸ Mitigation: 
   â€¢ File size monitoring at each phase
   â€¢ Proactive component splitting
   â€¢ Early refactoring planning
ğŸ†˜ Contingency: Emergency refactoring protocol
```

## PROGRESS TRACKING - PROGRESS MONITORING

### MILESTONE MANAGEMENT
Milestone tracking for complex projects:

```javascript
const projectMilestones = {
    analysis: {
        completion: '15%',
        deliverables: ['Architecture doc', 'Risk analysis', 'Timeline'],
        qualityGates: ['Stakeholder review', 'Technical validation']
    },
    
    foundationDevelopment: {
        completion: '40%', 
        deliverables: ['Core utilities', 'Service layer', 'Types'],
        qualityGates: ['File size compliance', 'Dependency audit']
    },
    
    coreImplementation: {
        completion: '70%',
        deliverables: ['Main components', 'Business logic', 'Integrations'],
        qualityGates: ['Quality score >85', 'Performance benchmarks']
    },
    
    integrationTesting: {
        completion: '90%',
        deliverables: ['Integration tests', 'E2E validation', 'Documentation'],
        qualityGates: ['All tests pass', 'Final quality audit']
    },
    
    deployment: {
        completion: '100%',
        deliverables: ['Production deployment', 'Monitoring setup'],
        qualityGates: ['Production validation', 'Performance monitoring']
    }
};
```

### QUALITY CHECKPOINT INTEGRATION
Quality control at each milestone:

```javascript
function runMilestoneQualityCheck(milestone) {
    const qualityAssessment = {
        fileSizeCompliance: auditFileSizes(),
        codeQualityScore: calculateQualityMetrics(),
        architecturalIntegrity: validateArchitecture(),
        performanceMetrics: benchmarkPerformance(),
        testCoverage: measureTestCoverage()
    };
    
    return determineMilestonePassing(qualityAssessment);
}
```

## TEAM COORDINATION - TEAM COORDINATION

### MULTI-DEVELOPER COORDINATION
For scenarios with multiple developers:

**Coordination strategies:**
- **Component ownership**: Areas each developer is responsible for
- **Interface contracts**: Agreements between components  
- **Merge protocols**: Code integration rules
- **Quality consistency**: Team-wide quality standards

```javascript
const teamCoordinationPlan = {
    componentOwnership: {
        'developer_1': ['UserManagement', 'Authentication'],
        'developer_2': ['Dashboard', 'Analytics'],
        'developer_3': ['Settings', 'Integrations']
    },
    
    sharedResources: {
        'utils': 'Shared ownership, PR review required',
        'types': 'Architecture lead approval required',
        'config': 'Team lead approval required'
    },
    
    integrationPoints: {
        'daily_sync': 'File size status, dependency changes',
        'weekly_review': 'Architecture compliance, quality metrics',
        'milestone_review': 'Complete quality assessment'
    }
};
```

### CODE INTEGRATION PROTOCOLS
Merge protocols for large teams:

**Pre-merge checklist:**
- [ ] File size compliance verified
- [ ] Quality gates passed
- [ ] No circular dependencies introduced
- [ ] Performance impact assessed
- [ ] Documentation updated
- [ ] Tests passing

## SCALABILITY PLANNING - SCALABILITY

### FUTURE-PROOF ARCHITECTURE
Design principles for growth:

**Scalability dimensions:**
- **Code scalability**: File organization, module structure
- **Performance scalability**: Lazy loading, code splitting
- **Team scalability**: Clear boundaries, minimal coupling
- **Feature scalability**: Plugin architecture, extension points

```javascript
function planScalableArchitecture(projectScope) {
    return {
        moduleStructure: designModularArchitecture(),
        performanceStrategy: planPerformanceOptimizations(),
        extensibilityPoints: identifyExtensionPoints(),
        maintenanceStrategy: planMaintenanceApproach()
    };
}
```

### PERFORMANCE CONSIDERATIONS
Performance planning in large projects:

**Performance strategies:**
- **Bundle optimization**: Code splitting, tree shaking
- **Lazy loading**: Component and route-based lazy loading  
- **Memory management**: Efficient state management
- **Rendering optimization**: Memoization, virtualization

## TECHNICAL DEBT MANAGEMENT

### DEBT PREVENTION STRATEGIES
Technical debt control in complex projects:

```javascript
function manageTechnicalDebt(projectProgress) {
    const debtMetrics = {
        fileSizeDebt: identifyOversizedFiles(),
        codeQualityDebt: measureQualityDeficits(),
        architecturalDebt: assessArchitecturalViolations(),
        documentationDebt: auditDocumentationGaps()
    };
    
    return prioritizeDebtReduction(debtMetrics);
}
```

**Debt categories and actions:**
- **File size debt**: Immediate refactoring required
- **Quality debt**: Progressive improvement plan
- **Architecture debt**: Planned refactoring phases
- **Documentation debt**: Parallel documentation efforts

## COMPLEX PROJECT COMMUNICATION

### STAKEHOLDER REPORTING
Comprehensive reporting for complex projects:

```
ğŸ—ï¸ KARMAÅIK PROJE DURUM RAPORU

ğŸ“Š GENEL Ä°LERLEME:
   ğŸ¯ Tamamlanan: [X%] - Milestone: [Current milestone]
   ğŸ“… Timeline: [on track/ahead/delayed] - [reason if delayed]
   ğŸ² Risk Status: [risk count] active risks, [mitigation count] mitigations

ğŸ“ DOSYA BOYUTU DURUMU:
   âœ… Compliant dosyalar: [X files]
   âš ï¸ YaklaÅŸan limitler: [X files] (600-699 lines)
   ğŸš« Ä°hlaller: [X files] (refactoring scheduled)

ğŸ›ï¸ ARCHÄ°TECTURE HEALTH:
   ğŸ¯ Design pattern compliance: [percentage]
   ğŸ”— Dependency health: [circular: X, unused: Y]
   ğŸ“ˆ Maintainability score: [X/100]

âš¡ PERFORMANCE METRÄ°KLERÄ°:
   ğŸ“¦ Bundle size: [X KB] (target: [Y KB])
   ğŸš€ Load time: [X ms] (target: [Y ms])
   ğŸ’¾ Memory usage: [acceptable/concerning]

ğŸ§ª KALÄ°TE DURUMU:
   ğŸ“Š Overall quality score: [X/100]
   ğŸ§¹ Code cleanliness: [status]
   ğŸ“š Documentation: [completion percentage]
   
ğŸš€ SONRAKÄ° ADIMLAR:
   â€¢ [Next milestone objectives]
   â€¢ [Immediate action items]
   â€¢ [Risk mitigation actions]
```

### DECISION TRACKING
Decision log for complex projects:

```javascript
const decisionLog = [
    {
        date: '2024-01-15',
        decision: 'Use Zustand instead of React Context',
        reason: 'Better performance for complex state',
        impact: 'All state management components affected',
        fileImpact: 'StateProvider.tsx will be refactored (current: 890 lines)'
    },
    
    {
        date: '2024-01-16', 
        decision: 'Split Dashboard component into 3 files',
        reason: 'File size violation (1,247 lines)',
        impact: 'Dashboard functionality maintained, better maintainability',
        implementation: 'DashboardMain.tsx, DashboardCharts.tsx, DashboardSettings.tsx'
    }
];
```

## SUCCESS CRITERIA - SUCCESS CRITERIA

### PROJECT SUCCESS METRICS
Success measurements for complex projects:

**Technical success criteria:**
- All files comply with size limits (< 1000 lines)
- Overall quality score > 85
- No circular dependencies
- Performance targets met
- Test coverage > 80%

**Business success criteria:**
- All requirements delivered
- Timeline adherence
- Stakeholder satisfaction
- Maintainability achieved
- Scalability validated

### POST-PROJECT REVIEW
Evaluation after project completion:

```
ğŸ“‹ PROJE TAMAMLANMA RAPORU

âœ… TEKNÄ°K BAÅARILAR:
   ğŸ“ Dosya boyutu compliance: [%100] 
   ğŸ“Š Kalite skoru: [X/100]
   âš¡ Performance hedefleri: [achieved/missed]
   ğŸ§ª Test coverage: [X%]

ğŸ’¼ BUSÄ°NESS BAÅARILAR:
   ğŸ¯ Requirements delivery: [%completion]
   ğŸ“… Timeline performance: [on time/delayed by X]
   ğŸ˜Š Stakeholder satisfaction: [score/10]

ğŸ“š LESSONS LEARNED:
   â€¢ [Key learnings from project]
   â€¢ [Process improvements identified]
   â€¢ [Best practices validated]

ğŸ”® GELECEKTEKÄ° PROJELERÄ° Ä°Ã‡Ä°N:
   â€¢ [Recommendations for future projects]
   â€¢ [Process optimizations]
   â€¢ [Tool and strategy improvements]
```

---

*Complex projects succeed through systematic approach, careful planning and continuous quality control. We maintain quality standards at every step by breaking complexity into small, manageable pieces.*
