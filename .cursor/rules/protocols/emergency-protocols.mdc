---
description: Emergency protocols - Limited file size exception for critical bug fixes (max +50 lines)
globs:
  - "**/*.js"
  - "**/*.jsx"
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.py"
alwaysApply: false
priority: 1
triggers: ['critical_bug_fix', 'security_vulnerability', 'production_error', 'system_crash_prevention']
conditions: ['severity = critical', 'production_impact = high']
file_size_exception: 50
emergency_override: true
mandatory_documentation: true
refactoring_schedule: immediate
depends_on: ['file-size-enforcement.mdc', 'language-rules.mdc']
---

# EMERGENCY PROTOCOLS - CRITICAL OVERRIDE

## CORE PHILOSOPHY - CONTROLLED EXCEPTION

This component is the only component with the authority to override normal rules. However, this authority is only used for real emergencies and is under strict control. Every exception must be documented and refactoring must be scheduled immediately.

## EMERGENCY DETECTION - EMERGENCY CLASSIFICATION

### EMERGENCY CRITERIA - STRICT DEFINITIONS

The following situations are considered real emergencies and limited exceptions to file size rules can be made:

**CRITICAL SEVERITY LEVELS:**
- **SEVERITY 1**: System completely crashed, users cannot access
- **SEVERITY 2**: Critical functions not working (payment, authentication)
- **SEVERITY 3**: Security vulnerability detected, immediate patch required
- **SEVERITY 4**: Data loss risk exists, immediate backup/fix required

```javascript
function classifyEmergency(issue) {
    const emergencyTypes = {
        SYSTEM_CRASH: {
            severity: 1,
            maxLineException: 50,
            timeLimit: '1 hour',
            refactoringDeadline: '24 hours'
        },
        CRITICAL_FUNCTION_DOWN: {
            severity: 2,
            maxLineException: 40,
            timeLimit: '2 hours',
            refactoringDeadline: '48 hours'
        },
        SECURITY_VULNERABILITY: {
            severity: 3,
            maxLineException: 30,
            timeLimit: '4 hours',
            refactoringDeadline: '24 hours'
        },
        DATA_LOSS_RISK: {
            severity: 4,
            maxLineException: 30,
            timeLimit: '6 hours',
            refactoringDeadline: '48 hours'
        }
    };
    
    return determineEmergencyType(issue, emergencyTypes);
}
```

### NON-EMERGENCY EXCLUSIONS - REJECTED SITUATIONS

The following situations are NOT considered emergencies and normal rules apply:

âŒ **UNACCEPTABLE JUSTIFICATIONS:**
- "This feature is very important, must be done immediately"
- "Deadline is approaching, need to handle quickly"
- "Just this once, we'll refactor later"
- "Client is waiting, need to hurry"
- "There's a bug but the system is working"
- "There's a performance problem but it's not critical"
- "UI bug, appearance is broken"

## EMERGENCY ACTIVATION PROTOCOLS

### PHASE 1: EMERGENCY VALIDATION
Every emergency claim is rigorously checked:

```javascript
function validateEmergency(userRequest) {
    const validation = {
        isProductionDown: assessProductionStatus(),
        userImpactLevel: calculateUserImpact(),
        businessCriticality: assessBusinessImpact(),
        timeToImpact: calculateTimeToResolution(),
        alternativeSolutions: checkForQuickAlternatives()
    };
    
    return validation.isProductionDown && 
           validation.userImpactLevel >= 'high' &&
           validation.businessCriticality >= 'critical';
}
```

**Validation questions:**
- Is the system currently inaccessible by users?
- Is this issue causing financial loss or data loss?
- Is there a risk of the security vulnerability being actively exploited?
- Do we not have the option to defer this issue until after refactoring?

### PHASE 2: EXCEPTION CALCULATION
If a real emergency is detected, the minimum necessary exception is calculated:

```javascript
function calculateMinimalException(emergencyType, targetFile) {
    const currentSize = getFileSize(targetFile);
    const fixRequirement = assessFixRequirement();
    
    const exception = {
        maxAdditionalLines: Math.min(
            emergencyType.maxLineException,
            fixRequirement.absoluteMinimum
        ),
        justification: emergencyType.reason,
        refactoringDeadline: emergencyType.refactoringDeadline,
        documentationRequired: true
    };
    
    return exception;
}
```

### PHASE 3: CONTROLLED IMPLEMENTATION
After the exception is approved, controlled implementation begins:

```javascript
// Emergency implementation protocol
function emergencyImplementation(fix, exception) {
    // Pre-implementation logging
    logEmergencyStart({
        timestamp: Date.now(),
        issue: fix.issue,
        targetFile: fix.targetFile,
        currentSize: getFileSize(fix.targetFile),
        maxException: exception.maxAdditionalLines,
        estimatedAddition: fix.estimatedLines
    });
    
    // Implement with line counting
    const implementationResult = applyFixWithLineTracking(fix);
    
    // Post-implementation validation  
    validateEmergencyCompliance(implementationResult, exception);
    
    // Schedule mandatory refactoring
    scheduleRefactoring(exception.refactoringDeadline);
}
```

## EMERGENCY IMPLEMENTATION LIMITS

### MAXIMUM ADDITIONS BY SEVERITY
Maximum addition limits by emergency type:

```javascript
const EMERGENCY_LIMITS = {
    SYSTEM_CRASH: {
        maxLines: 50,
        examples: [
            "Server crash fix",
            "Database connection restore",
            "Critical API endpoint repair"
        ]
    },
    CRITICAL_FUNCTION_DOWN: {
        maxLines: 40,
        examples: [
            "Payment processor fix",
            "User authentication repair", 
            "Core business logic fix"
        ]
    },
    SECURITY_VULNERABILITY: {
        maxLines: 30,
        examples: [
            "SQL injection patch",
            "Authentication bypass fix",
            "Data exposure prevention"
        ]
    },
    DATA_LOSS_RISK: {
        maxLines: 30,
        examples: [
            "Data corruption prevention",
            "Backup mechanism fix",
            "Transaction rollback repair"
        ]
    }
};
```

### IMPLEMENTATION CONSTRAINTS
Even emergency implementation is within limits:

- âœ… **PERMITTED**: Minimum necessary code addition
- âœ… **PERMITTED**: Specific code that fixes critical bug
- âœ… **PERMITTED**: Code that closes security vulnerability
- âœ… **PERMITTED**: Code that prevents system crash

- âŒ **NOT PERMITTED**: Feature enhancement
- âŒ **NOT PERMITTED**: Code optimization "while we're at it"
- âŒ **NOT PERMITTED**: Refactoring during emergency
- âŒ **NOT PERMITTED**: Scope creep

## MANDATORY DOCUMENTATION - REQUIRED DOCUMENTATION

Every emergency intervention is documented in detail:

### EMERGENCY LOG FORMAT
```javascript
/*
 * EMERGENCY INTERVENTION LOG
 * =========================
 * Timestamp: 2024-01-15 14:30:22 UTC
 * Issue ID: EMERGENCY-2024-001
 * Severity: CRITICAL (System Crash)
 * 
 * PROBLEM DESCRIPTION:
 * Production database connection pool exhausted, causing complete
 * system unavailability. Users cannot access the application.
 * 
 * IMPACT ASSESSMENT:
 * - Affected users: ~10,000 active sessions
 * - Business impact: $5,000/hour revenue loss
 * - SLA breach: YES (99.9% uptime commitment)
 * 
 * EMERGENCY FIX APPLIED:
 * File: src/database/ConnectionManager.js
 * Lines before: 734 lines
 * Lines added: 23 lines (EMERGENCY EXCEPTION)
 * Lines after: 757 lines
 * 
 * CHANGES MADE:
 * 1. Added connection pool size validation
 * 2. Implemented connection recycling mechanism  
 * 3. Added emergency connection cleanup
 * 
 * REFACTORING SCHEDULED:
 * Deadline: 2024-01-16 14:30:22 UTC (24 hours)
 * Plan: Extract connection management to separate service
 * Estimated effort: 4 hours
 * 
 * SIGN-OFF:
 * Emergency authorized by: System Rules Override
 * Technical lead approval: PENDING
 * Refactoring assignment: PENDING
 */
```

### EMERGENCY REPORT
A detailed report is created after each emergency:

```
ðŸš¨ ACÄ°L DURUM MÃœDAHALE RAPORU

ðŸ“Š DURUM Ã–ZETÄ°:
   ðŸŽ¯ Sorun: [detailed problem description]
   âš¡ Åžiddet: [CRITICAL/HIGH severity]
   â±ï¸ Toplam downtime: [X minutes]
   ðŸ‘¥ Etkilenen kullanÄ±cÄ±: [X users]

ðŸ”§ UYGULANAN Ã‡Ã–ZÃœM:
   ðŸ“ Hedef dosya: [file path]
   ðŸ“ Ã–nceki boyut: [X lines]
   âž• Eklenen: [Y lines] (ACÄ°L Ä°STÄ°SNA)
   ðŸ“ Yeni boyut: [X+Y lines]

âš ï¸ KURAL Ä°STÄ°SNASI:
   ðŸš« Normal limit: 700 satÄ±r
   ðŸ“ˆ Mevcut durum: [X+Y lines] (Ä°STÄ°SNA AKTÄ°F)
   â° Ä°stisna sÃ¼resi: [deadline]
   
ðŸ”„ REFACTORING PLANI:
   ðŸ“… Deadline: [definite date]
   ðŸ“‹ Plan: [detailed refactoring strategy]
   â±ï¸ Tahmini sÃ¼re: [X hours]
   
âœ… ACÄ°L DURUM SONLANDIRILDI
```

## REFACTORING ENFORCEMENT - MANDATORY CLEANUP

### AUTOMATIC SCHEDULING
Every emergency intervention automatically creates a refactoring task:

```javascript
function scheduleEmergencyRefactoring(emergency) {
    const refactoringTask = {
        id: `REFACTOR-${emergency.id}`,
        priority: 'CRITICAL',
        deadline: calculateRefactoringDeadline(emergency.severity),
        description: `Emergency refactoring for ${emergency.file}`,
        currentSize: emergency.newFileSize,
        targetSize: 'under 700 lines',
        strategy: generateRefactoringStrategy(emergency)
    };
    
    // Add to priority queue
    addToCriticalTasks(refactoringTask);
    
    // Set reminders  
    setRefactoringReminders(refactoringTask);
    
    return refactoringTask;
}
```

### REFACTORING DEADLINE CALCULATION
Refactoring deadlines by emergency severity:

- **SYSTEM CRASH**: Within 24 hours
- **CRITICAL FUNCTION**: Within 48 hours  
- **SECURITY ISSUE**: Within 24 hours
- **DATA RISK**: Within 48 hours

### NON-COMPLIANCE CONSEQUENCES
If refactoring deadline is missed:

```
âš ï¸ REFACTORING DEADLINE MISSED!

ðŸš¨ DURUM: Kritik refactoring gÃ¶revi tamamlanmadÄ±
ðŸ“ Dosya: [emergency file path]
ðŸ“… Deadline: [missed deadline]
â° Gecikme: [X hours late]

ðŸ”’ AKTÄ°F KISITLAMALAR:
   âŒ Bu dosyaya yeni kod eklenemez
   âŒ Bu dosyayla ilgili yeni feature'lar bloke
   âŒ Proje build warning'leri aktif

ðŸŽ¯ Ä°VEDÄ° EYLEM GEREKLÄ°:
   1. Refactoring'i derhal tamamla
   2. Dosya boyutunu 700 satÄ±r altÄ±na indir  
   3. Test coverage'i doÄŸrula
   4. Code review yap
```

## EMERGENCY PREVENTION - PREVENTION STRATEGIES

### EARLY WARNING SYSTEM
Early warning system to prevent emergencies:

```javascript
function checkEmergencyRisk(project) {
    const riskFactors = {
        largeFiles: countFilesOverSize(600), // 600+ line files are risks
        couplingLevel: assessModuleCoupling(),
        testCoverage: getTestCoverage(),
        techDebt: assessTechnicalDebt()
    };
    
    if (riskFactors.largeFiles > 5) {
        warn("EMERGENCY RISK: Too many large files detected");
    }
    
    if (riskFactors.couplingLevel > 0.7) {
        warn("EMERGENCY RISK: High coupling, changes are risky");
    }
}
```

### PROACTIVE REFACTORING
Proactive refactoring to prevent emergencies:

- Automatic warning for 600+ line files
- Coupling analysis and risk assessment
- Regular maintenance windows
- Technical debt tracking

## QUALITY GATES - EMERGENCY QUALITY CONTROL

### PRE-EMERGENCY VALIDATION
Even in emergencies, minimum quality controls are performed:

- [ ] **Syntax check**: Is the code functional?
- [ ] **Import validation**: Are new imports unnecessary?
- [ ] **Basic testing**: Does basic functionality work?
- [ ] **Security check**: Does it not create security vulnerabilities?

### POST-EMERGENCY VERIFICATION
Validation after emergency:

- [ ] **Fix effectiveness**: Was the problem actually solved?
- [ ] **No regression**: Did it not cause other problems?
- [ ] **Documentation complete**: Is documentation complete?
- [ ] **Refactoring scheduled**: Was cleanup task created?

---

*Emergencies are unavoidable, but with controlled intervention we both solve the problem and maintain system integrity. Every exception is temporary, every solution is documented, every intervention must be reversible.*
